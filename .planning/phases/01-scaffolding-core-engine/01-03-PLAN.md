---
phase: 01-scaffolding-core-engine
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified: [
  "src/lib/poker/state-machine.ts",
  "src/lib/poker/betting.ts",
  "src/lib/poker/types.ts",
  "src/lib/poker/__tests__/state-machine.test.ts",
  "src/lib/poker/__tests__/engine.test.ts"
]
autonomous: true
requirements: [PH1-ENGINE]
---

<objective>
Implement the Game State Machine and Betting Logic for Preflop and Flop stages of Heads-up NLHE.

Purpose: Control the flow of the game and handle user/bot actions.
Output: A state machine that transitions between game stages and manages the pot and player stacks.
</objective>

<execution_context>
@C:/Users/sinha/.gemini/get-shit-done/workflows/execute-plan.md
@C:/Users/sinha/.gemini/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-scaffolding-core-engine/01-01-SUMMARY.md
@.planning/phases/01-scaffolding-core-engine/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Game State Machine (Preflop & Flop)</name>
  <files>src/lib/poker/state-machine.ts, src/lib/poker/types.ts, src/lib/poker/__tests__/state-machine.test.ts</files>
  <action>
    1. Define `GameState` type including:
       - `stage`: 'PREFLOP', 'FLOP', 'SHOWDOWN'
       - `pot`: number
       - `communityCards`: Card[]
       - `players`: { id: string, stack: number, holeCards: Card[], currentBet: number }[]
       - `activePlayerIndex`: number
    2. Implement a `PokerGame` class that:
       - Initializes a new hand (shuffles, deals 2 cards to each player).
       - Manages the transition from PREFLOP to FLOP (dealing 3 community cards).
       - Tracks whose turn it is.
    3. Ensure the state is immutable-friendly (returns new state objects).
  </action>
  <verify>
    <automated>node --test src/lib/poker/__tests__/state-machine.test.ts</automated>
    <manual>Verify that the game starts in PREFLOP and transitions to FLOP after both players act.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Game state transitions correctly between Preflop and Flop.</done>
</task>

<task type="auto">
  <name>Task 2: Betting Rules and Pot Management</name>
  <files>src/lib/poker/betting.ts, src/lib/poker/state-machine.ts, src/lib/poker/__tests__/engine.test.ts</files>
  <action>
    1. Implement `handleAction(action: Action): GameState` where `Action` is:
       - `{ type: 'FOLD' | 'CHECK' | 'CALL' | 'RAISE', amount?: number }`.
    2. Add logic to:
       - Deduct chips from stacks and add to `currentBet`.
       - Update the `pot` when a betting round ends.
       - Identify when a betting round is "closed" (both players have put in the same amount or one folded).
    3. Implement Small Blind / Big Blind posting at the start of PREFLOP.
    4. Create `src/lib/poker/__tests__/engine.test.ts` to test full betting scenarios.
  </action>
  <verify>
    <automated>node --test src/lib/poker/__tests__/engine.test.ts</automated>
    <manual>Test a scenario: SB calls, BB checks -> Stage moves to FLOP. Test a scenario: SB folds -> Hand ends.</manual>
    <sampling_rate>run after this task commits, before next task begins</sampling_rate>
  </verify>
  <done>Betting logic correctly manages stacks, pot, and round closing.</done>
</task>

</tasks>

<must_haves>
  truths:
    - "Game starts with blinds posted"
    - "Calling a bet makes stacks equal in the current round"
    - "Stage moves to FLOP after PREFLOP betting ends"
  artifacts:
    - path: "src/lib/poker/state-machine.ts"
      provides: "Game flow control"
    - path: "src/lib/poker/betting.ts"
      provides: "Action validation and stack management"
  key_links:
    - from: "src/lib/poker/state-machine.ts"
      to: "src/lib/poker/betting.ts"
      via: "action processing"
</must_haves>

<success_criteria>
- A full hand can be played from DEAL to FLOP transition.
- Stacks are correctly updated after actions.
- Betting rounds close correctly when bets are matched.
</success_criteria>

<output>
After completion, create `.planning/phases/01-scaffolding-core-engine/01-03-SUMMARY.md`
</output>
